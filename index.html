<html>
<!DOCTYPE html>
<meta charset="utf-8">
<style>



</style>

<body>
    <div style="position: fixed;
    top: 0;
    right: 800;">
        <txt>Aang</txt><input type="checkbox" id="Aang" data="0" onchange="checkboxUpdate(event)" checked="true"></br>
        <txt>Sokka</txt><input type="checkbox" id="Sokka" data="1" onchange="checkboxUpdate(event)"></br>
        <txt>Katara</txt><input type="checkbox" id="Katara" data="2" onchange="checkboxUpdate(event)"></br>
        <txt>Zuko</txt><input type="checkbox" id="Zuko" data="3" onchange="checkboxUpdate(event)"></br>
        <txt>Toph</txt><input type="checkbox" id="Toph" data="4" onchange="checkboxUpdate(event)"></br>
        <txt>Iroh</txt><input type="checkbox" id="Iroh" data="5" onchange="checkboxUpdate(event)"></br>
        <txt>Azula</txt><input type="checkbox" id="Azula" data="6" onchange="checkboxUpdate(event)"></br>
        <txt>Jet</txt><input type="checkbox" id="Jet" data="7" onchange="checkboxUpdate(event)"></br>
        <txt>Suki</txt><input type="checkbox" id="Suki" data="8" onchange="checkboxUpdate(event)"></br>
        <txt>Zhao</txt><input type="checkbox" id="Zhao" data="9" onchange="checkboxUpdate(event)"></br>
        <txt>Mai</txt><input type="checkbox" id="Mai" data="10" onchange="checkboxUpdate(event)"></br>
        <txt>Hakoda</txt><input type="checkbox" id="Hakoda" data="11" onchange="checkboxUpdate(event)">
    </div>

    <!-- d3 v7 integration -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/danfojs@1.1.2/lib/bundle.min.js"></script>


    <script>

        selected = ["Aang"]
        zDomain = ["Aang", "Sokka", "Katara", "Zuko", "Toph", "Iroh", "Azula", "Jet", "Suki", "Zhao"]
        selectedBool = [true, false, false, false, false, false, false, false, false, false]
        strokeLinecap = "round", // stroke line cap of the line
            strokeLinejoin = "round", // stroke line join of the line
            strokeWidths = [2.5, 2, 1.5, 3, 2, 2],// stroke width of line, in pixels // *************
            strokeOpacities = [1, 1, 1, 0.6, 1, 1], // stroke opacity of line // *************
            colors = d3.schemeTableau10 // array of categorical colors
        var g1
        var svg
        var top_words
        var line
        var pi_div
        var selected_word
        var Y1, Y2, Y3, Y4, Y5, Y6, Y7, Y8, Y9, Y10
        var word_counts_per_character;
        var arc = d3.arc()
                        .outerRadius(100)
                        .innerRadius(0);
        function checkboxUpdate(e) {
            if (e.target.checked) {
                selected.push(e.target.id)
                selectedBool[e.target.getAttribute("data")] = true
                d3.select("#line-" + e.target.id).transition().duration(1000)
                    .attr("opacity", 1);
            }
            else {
                selectedBool[e.target.getAttribute("data")] = false
                const index = selected.indexOf(e.target.id);
                if (index > -1) { // only splice array when item is found
                    selected.splice(index, 1); // 2nd parameter means remove one item only
                }
                d3.select("#line-" + e.target.id).transition().duration(1000)
                    .attr("opacity", 0);
            }
            updateTopWords()
            updatePi()


        }

        fetch('LineVisual1.csv').then(async (data) => {
            const raw_csv_data = await data.text();
            const first_eol = raw_csv_data.indexOf('\n');
            data = d3.csvParse(raw_csv_data.substring(first_eol + 1));

            //console.log(data)


            x = data => data.Episode,
                y = data => data.Aang,
                y2 = data => data.Sokka,
                y3 = data => data.Katara,
                y4 = data => data.Zuko,
                y5 = data => data.Toph,
                y6 = data => data.Iroh,
                y7 = data => data.Azula,
                y8 = data => data.Jet,
                y9 = data => data.Suki,
                y10 = data => data.Zhao,
                yLabel = "Word Count",
                xLabel = "â†’ Episode # ",
                width = 600,
                height = 400






            curve = d3.curveLinear, // method of interpolation between points
                marginTop = 20 // top margin, in pixels
            marginRight = 80, // right margin, in pixels
                marginBottom = 30, // bottom margin, in pixels
                marginLeft = 40, // left margin, in pixels
                width = 640, // outer width, in pixels
                height = 400, // outer height, in pixels
                xType = d3.scaleLinear, // the x-scale type
                xDomain = [0, 60], // [xmin, xmax]
                xRange = [marginLeft, width - marginRight], // [left, right]
                xLabel,// a label for the x-axis
                yType = d3.scaleLinear, // the y-scale type
                yDomain = [0, 800], // [ymin, ymax]
                yRange = [height - marginBottom, marginTop], // [bottom, top]
                color = "currentColor" // stroke color of line

            //colors = ["#aaa", "green", "blue", "red","orange","yellow"], // color of the 6 lines
            var defined, yFormat
            var characters_selected = [true, false, true, false, false, false, false, false, false, false]
            // Compute values.
            const X1 = d3.map(data, x);
            Y1 = d3.map(data, y);
            Y2 = d3.map(data, y2);
            Y3 = d3.map(data, y3);
            Y4 = d3.map(data, y4);
            Y5 = d3.map(data, y5);
            Y6 = d3.map(data, y6);// *************
            Y7 = d3.map(data, y7);// *************
            Y8 = d3.map(data, y8);// *************
            Y9 = d3.map(data, y9);// *************
            Y10 = d3.map(data, y10);// *************


            const I = d3.range(X1.length);
            if (defined === undefined) defined = (d, i) => !isNaN(X1[i]) && !isNaN(Y1[i]);
            const D = d3.map(data, defined);
            const Xs = d3.sort(I.filter(i => D[i]).map(i => X1[i])); // for bisection

            // Compute default domains.
            if (xDomain === undefined) xDomain = d3.extent(X1);
            if (yDomain === undefined) yDomain = [0, d3.max(Y1, Y2)];

            // Construct scales and axes.
            const xScale = xType(xDomain, xRange).interpolate(d3.interpolateRound);
            const yScale = yType(yDomain, yRange);
            const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
            const yAxis = d3.axisLeft(yScale).ticks(null, yFormat);

            // Construct a line generator.
            line = d3.line()
                .defined((y, i) => !isNaN(X1[i]) && !isNaN(y))
                .curve(curve)
                .x((y, i) => xScale(X1[i]))
                .y((y, i) => yScale(y));

            svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
                .attr("font-family", "sans-serif")
                .attr("font-size", 10)
                .style("background", "white") // background color of the chart
                .on("touchstart", event => event.preventDefault()) // add event listener
                .on("pointermove", pointermoved);// add event listener for touch start

            var options = ["Option 1", "Option 2", "Option 3"];


            /* Add Legend */
            // Add one dot in the legend for each name.
            var size = 20
            svg.selectAll("mydots")
                .data(zDomain)
                .enter()
                .append("rect")
                .attr("x", marginTop * 55)
                .attr("y", (d, i) => { return 2 * marginTop + i * (size + 5) }) //
                .attr("width", size)
                .attr("height", size)
                .style("fill", (d, i) => colors[i])

            // Add one dot in the legend for each name.
            svg.selectAll("mylabels")
                .data(zDomain)
                .enter()
                .append("text")
                .attr("x", marginTop * 55 + size * 1.2)
                .attr("y", (d, i) => { return 2 * marginTop + i * (size + 5) + (size / 2) })
                .style("fill", (d, i) => colors[i])
                .text((d) => d)
                .attr("text-anchor", "left")
                .style("alignment-baseline", "middle")


            /*Add Chart details*/
            svg.append("g")
                .attr("transform", `translate(0,${height - marginBottom})`)
                .call(xAxis)
                .call(g => g.append("text")
                    .attr("x", width - marginRight)
                    .attr("y", 10)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .attr("font-size", 14)
                    .attr("font-weight", 700)
                    .text(xLabel));

            svg.append("g")
                .attr("transform", `translate(${marginLeft},0)`)
                .call(yAxis)
                //.call(g => g.select(".domain").remove())
                .call(g => g.selectAll(".tick line").clone() // gridline
                    .attr("x2", width - marginLeft - marginRight)
                    .attr("stroke-opacity", 0.1))
                .call(g => g.append("text")
                    .attr("x", -marginLeft)
                    .attr("y", 10)
                    .attr("fill", "currentColor")
                    .attr("text-anchor", "start")
                    .attr("font-size", 14)
                    .attr("font-weight", 700)
                    .text(yLabel));
            g1 = svg.append("g")
            drawlines()//[Y1,Y2,Y3,Y4, Y5, Y6, Y7, Y8, Y9, Y10])
            /////////////////////////////////////////////////////
            /*Add cross over and moving mouse event*/
            const rule = svg.append("g");

            rule.append("line")
                .attr("y1", marginTop + 100)
                .attr("y2", height - marginBottom - 15)
                .attr("stroke", "#aaa")
                .attr("stroke-width", 2.5)
                .attr("stroke-opacity", 0.75);

            const ruleLabel = rule.append("text")
                .attr("y", height - marginBottom - 15)
                .attr("fill", "currentColor")
                .attr("text-anchor", "middle")
                .attr("dy", "1em");

            const serie = rule.append("text")
                .attr("x", 10)
                .attr("fill", "currentColor")
                .attr("text-anchor", "middle")
                .attr("dy", "0.9em");

            const serie2 = rule.append("text")
                .attr("x", 10)
                .attr("fill", "currentColor")
                .attr("text-anchor", "middle")
                .attr("dy", "2em");
            const serie3 = rule.append("text")
                .attr("x", 10)
                .attr("fill", "currentColor")
                .attr("text-anchor", "middle")
                .attr("dy", "3em");
            const serie4 = rule.append("text")
                .attr("x", 10)
                .attr("fill", "currentColor")
                .attr("text-anchor", "middle")
                .attr("dy", "4em");
            const serie5 = rule.append("text")
                .attr("x", 10)
                .attr("fill", "currentColor")
                .attr("text-anchor", "middle")
                .attr("dy", "5em");

            function update(x) {
                x = Xs[d3.bisectCenter(Xs, x)];
                rule.attr("transform", `translate(${xScale(x)},0)`);
                ruleLabel.text(x);
                var i = I[d3.bisector(i => X1[i]).center(I, x)];
                serie.text(zDomain[0] + ": " + Y1[i] + ", " + zDomain[1] + ": " + Y2[i]);// *************
                serie2.text(zDomain[2] + ": " + Y3[i] + ", " + zDomain[3] + ": " + Y4[i]);// *************
                serie3.text(zDomain[4] + ": " + Y5[i] + ", " + zDomain[5] + ": " + Y6[i]);// *************
                serie4.text(zDomain[6] + ": " + Y7[i] + ", " + zDomain[7] + ": " + Y8[i]);// *************
                serie5.text(zDomain[8] + ": " + Y9[i] + ", " + zDomain[9] + ": " + Y10[i]);// *************

                svg.property("value", x).dispatch("input", { bubbles: true }); // for viewof
            }

            function pointermoved(event) { // touch start event
                update(xScale.invert(d3.pointer(event)[0]));
            }

            update(xDomain[0]);
        })
        function drawlines(data) {
            var lines = g1
                .attr("fill", "none")
                .attr("stroke-linejoin", strokeLinejoin)
                .attr("stroke-linecap", strokeLinecap)
                .selectAll()
                .data([Y1, Y2, Y3, Y4, Y5, Y6, Y7, Y8, Y9, Y10])// *************
                .join("path")
                .transition()
                .duration(1000)
                .attr("stroke", (d, i) => charColor(zDomain[i]))
                .attr("stroke-width", (d, i) => strokeWidths[i])
                .attr("stroke-opacity", (d, i) => strokeOpacities[i])
                .attr("d", line)
                .attr("id", (d, i) => "line-" + zDomain[i])
                .attr("opacity", (d, i) => {
                    if (i == 0) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                });

        }
        // console.log("a")
        dfd.readCSV("word_counts_per_character.csv")
            .then(df => {
                d3.select("body").append("br")


                d3.select("body").append("text")
                    .text("Top Words For Character Selection:")
                top_words = d3.select("body").append("ol")
                d3.select("body").append("br")

                pi_svg = d3.select("body").append("svg")
                    .attr("class", "tooltip-donut")
                    .attr("width", 300)
                    .attr("height", 300)
                pi_div = pi_svg.append("g")
                    .attr("transform", "translate(" + 100 + "," + 100 + ")");

                //.style("opacity", 1)
                //.text("help")

                word_counts_per_character = df
                updateTopWords()

            }).catch(err => {
                console.log(err)
            })
        function updateTopWords() {

            var sum = 0
            var words = {}
            word_counts_per_character.$columns.forEach(element => {
                words[element] = 0;
                selectedBool.forEach((x, i) => {
                    if (x) {
                        words[element] += word_counts_per_character[element].$data[i + 1]
                    }
                })
            })


            // Create items array
            var items = Object.keys(words).map(function (key) {
                return [key, words[key]];
            });

            // Sort the array based on the second element
            items.sort(function (first, second) {
                return second[1] - first[1];

            });
            items = items.slice(0, 5)
            selected_word=items[0][0]
            updatePi()

            var list = top_words.selectAll("li")
                .data(items)

            list

                .join("li")
                .attr('style',(x,i)=>{
                    if(i==0){
                        return 'border-style: solid;  width: fit-content;'
                    }
                    else{
                        return "width: fit-content;";
                    }
                    
                })
                .text(d => {
                    return d[0]
                })
                .on('mouseover', function (d, i) {
                    
                    d3.selectAll(this.parentNode.childNodes).attr('style', 'width: fit-content;');
                    d3.select(this).transition()
                        .duration('50')
                        .attr('style', 'border-style: solid;  width: fit-content;');
                    //Makes the new div appear on hover:
                    selected_word=d.srcElement.innerHTML
                    updatePi()
                })
                
        }
        function charColor(char) {
            if (char == "Aang") {
                return "orange"
            }
            else if (char == "Sokka") {
                return "blue"
            }
            else if (char == "Toph") {
                return "green"
            }
            else {
                return "yellow"
            }
        }
        function updatePi(){
                    char_counts = []
                    selectedBool.forEach((x, i) => {
                        if (x) {
                            char_counts.push([zDomain[i], word_counts_per_character[selected_word].$data[i + 1]])
                        }
                    })

                    var pie = d3.pie().value(function (d) {
                        return d[1];
                    })
                        .sort(function (a, b) {
                            console.log(a)
                            return d3.ascending(a[0], b[0]);
                        })

                   
                    var path = pi_div.selectAll("path")
                        .data(pie(char_counts))

                    path

                        .join("path")
                        //.transition()
                        //.duration(500)
                        .attr("d", arc)
                        .attr("fill", "red")
                        .attr("fill", function (d) {
                            return charColor(d.data[0])
                        })
        }
       


    </script>

</body>

</html>